# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AIDetection
                                 A QGIS plugin
 Using deep learning to detect interested block 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-05-30
        git sha              : $Format:%H$
        copyright            : (C) 2021 by GDOU
        email                : 2270514313@qq.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication,QFileSystemWatcher,Qt
from qgis.PyQt.QtGui import QIcon,QPixmap
from qgis.PyQt.QtWidgets import QAction,QFileDialog

import numpy
# Initialize Qt resources from file resources.py
from . import predict
from .resources import *
# Import the code for the dialog
from .AI_Detection_dialog import AIDetectionDialog
import os.path
import cv2




'''打开选择文件夹对话框'''
# 全局变量：
# 路径选择
# iFolderpath:用户选择放入模型的文件夹路径
# oFolderpath:用户选择模型运行结果的保存路径
# 图层长宽
# Wd宽度 Hg长度 单位：度 PWd长度像素值 PHg长度像素值 单位：像素

iFilepath=""
oFolderpath=""
Wd=0
Hg=0
PWd=0
PHg=0
#  先验区的xy坐标
# # 左上角x
# PblocklX = []
# # 左上角y
# PblocklY = []
# # 右下角x
# PblockrX = []
# # 右下角y
# PblockrY = []
# 起点 StartX StartY 单位:度
StartX=0
StartY=0


class AIDetection:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # 先验区的像素点xy最大最小值坐标
        self.PblockminX = []
        self.PblockminY=[]
        self.PblockmaxX=[]
        self.PblockmaxY=[]
        # 先验点的像素点xy最大最小值坐标
        self.PpointminX = []
        self.PpointminY=[]
        self.PpointmaxX=[]
        self.PpointmaxY=[]
        # 運行先驗點或先驗區的標志
        self.flag=0 #0運行先驗區 1運行先驗點
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'AIDetection_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Artificial Intelligence Detection')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('AIDetection', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/AI_Detection/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'AI Detection'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Artificial Intelligence Detection'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = AIDetectionDialog()
            self.dlg.savePath.clicked.connect(self.SavePath)
            self.dlg.runModel.clicked.connect(self.Detect)
            self.dlg.readBlock.clicked.connect(self.ReadBlock)
            self.dlg.selectMap.clicked.connect(self.selectMap)
            self.dlg.readPoint.clicked.connect(self.readPoint)
            self.dlg.progressBar.setValue(0)




        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    #     获取保存路径函数
    def SavePath(self):
        self.oFolderpath=QFileDialog.getExistingDirectory()
        print("oFolderpath:",self.oFolderpath)
    #    运行模型的函数
    def Detect(self):
        if self.flag==0:
            predict.run(self.oFolderpath + '/1.png',self)
            # cv2.imshow('img', img)
            # cv2.waitKey(0)
            # cv2.destroyAllWindows()

            # 原始图片展示
            # img = QPixmap(save_path+'/1.png')
            # scarePixmap = img.scaled(471, 321, aspectRatioMode=Qt.KeepAspectRatio)
            # self.dlg.showP.setPixmap(scarePixmap)
            # 结果图片展示
            path__ = self.oFolderpath + '/1.png' + '_predict.png'  # 结果图片地址
            img_result = QPixmap(path__)
            scarePixmap_result = img_result.scaled(471, 321, aspectRatioMode=Qt.KeepAspectRatio)
            self.dlg.showR.setPixmap(scarePixmap_result)
            print(self.PblockminX)
            self.dlg.progressBar.setValue(100)
        else:
            predict.run(self.oFolderpath + '/2.png',self)
            # cv2.imshow('img', img)
            # cv2.waitKey(0)
            # cv2.destroyAllWindows()

            # 原始图片展示
            # img = QPixmap(save_path+'/1.png')
            # scarePixmap = img.scaled(471, 321, aspectRatioMode=Qt.KeepAspectRatio)
            # self.dlg.showP.setPixmap(scarePixmap)
            # 结果图片展示
            path__ = self.oFolderpath + '/2.png' + '_predict.png'  # 结果图片地址
            img_result = QPixmap(path__)
            scarePixmap_result = img_result.scaled(471, 321, aspectRatioMode=Qt.KeepAspectRatio)
            self.dlg.showR.setPixmap(scarePixmap_result)
            print(self.PblockminX)
            self.dlg.progressBar.setValue(100)


        


    #获取图层的信息
    def selectMap(self):
        i = self.iface.activeLayer()
        self.StartX=float(i.extent().xMinimum())
        self.StartY=float(i.extent().yMinimum())
        #地图地理坐标点
        self.Wd=float (i.extent().xMaximum()-i.extent().xMinimum())
        print(self.Wd)
        self.Hg =float(i.extent().yMaximum() - i.extent().yMinimum())
        print(self.Hg)
        self.iFilepath=i.dataProvider().dataSourceUri()  # 地图文件路径
        print(self.iFilepath)
        self.PWd= float(i.width())
        self.PHg= float(i.height())   # 地图宽高（像素）
        print(self.PWd)
        print(self.PHg)


        # 获取标记区域
    def ReadBlock(self):
        print("读取区域")
        self.flag = 0
        i = self.iface.activeLayer()
        for feat in i.getFeatures():
            geom = feat.geometry()
            t = geom.asPolygon()
            pxlist = []
            pylist = []
            for p in t[0]:
                pxlist.append(p.x())
                pylist.append(p.y())
            print('--------')
            print(self.PWd)
            print(self.PHg)
            # 像素值
            pminX = (float(float(min(pxlist)) - self.StartX) / self.Wd) * self.PWd  # min x
            pmaxX = (float(float(max(pxlist)) - self.StartX) / self.Wd) * self.PWd  # max x
            pminY = (float(float(min(pylist)) - self.StartY) / self.Hg) * self.PHg  # min y
            pmaxY = (float(float(max(pylist)) - self.StartY) / self.Hg) * self.PHg  # max y
            print("compute finished")
            self.PblockminX.append(pminX)
            self.PblockmaxX.append(pmaxX)
            self.PblockminY.append(pminY)
            self.PblockmaxY.append(pmaxY)
            print('min x y:', min(pxlist), max(pylist))  # 先验区左上xy坐标
            print('min x y px:', self.PblockminX, self.PblockminY)  # 先验区左上px xy坐标
            print('max x y:', max(pxlist), min(pylist))  # 先验区右下xy坐标
            print('max x y px:', self.PblockmaxX, self.PblockmaxY)  # 先验区右下px xy坐标
            # 剪切圖片
            path = self.iFilepath  # 读取文件地址
            save_path = self.oFolderpath  # 保存文件地址
            img = cv2.imread(path, 1)
            print(img)
            print(self.PblockminX)
            # 坐标1
            x1 = int(self.PblockminX[0])
            y1 = int(self.PHg - self.PblockminY[0])
            # 坐标2
            x2 = int(self.PblockmaxX[0])
            y2 = int(self.PHg - self.PblockmaxY[0])
            # 计算宽，高
            w = x2 - x1
            h = y2 - y1
            print(w)
            print(h)
            img = img[y2:y1, x1:x2, :]
            cv2.imwrite(save_path + '/1.png', img)
            # 原始图片展示
            img = QPixmap(self.oFolderpath + '/1.png')
            scarePixmap = img.scaled(471, 321, aspectRatioMode=Qt.KeepAspectRatio)
            self.dlg.showP.setPixmap(scarePixmap)
    # 获取数据============

    # 获取点的坐标值
    def readPoint(self):
        print("获取点的坐标")
        self.flag = 1
        # 获取点集坐标
        i = self.iface.activeLayer()
        if i.providerType() == 'memory':
            xlist = []
            ylist = []
            pxlist = []
            pylist = []
            for feat in i.getFeatures():
                geom = feat.geometry()
                t = geom.asMultiPoint()
                xlist.append(t[0][0])
                ylist.append(t[0][1])
                pxlist.append(float(float(t[0][0] - self.StartX) / self.Wd) * self.PWd)
                pylist.append(float(float(t[0][1] - self.StartY) / self.Hg) * self.PHg)
            print("地理坐标系：")
            print(xlist)  # 所有点的x坐标
            print(ylist)  # 所有点的y坐标
            print("起始点X Y")
            print(self.StartX)
            print(self.StartY)
            print("宽 高：")
            print(self.Wd)
            print(self.Hg)
            print("像素宽 高：")
            print(self.PWd)
            print(self.PHg)
            print("像素点：")
            print(pxlist)  # 所有点的x坐标
            print(pylist)  # 所有点的y坐标
            self.PpointminX.append(int(min(pxlist)))
            self.PpointminY.append(int(min(pylist)))
            self.PpointmaxX.append(int(max(pxlist)))
            self.PpointmaxY.append(int(max(pylist)))

            # 显示剪切图像
            path = self.iFilepath  # 读取文件地址
            print(path)
            save_path = self.oFolderpath  # 保存文件地址
            print(save_path)
            img = cv2.imread(path)
            print(self.PpointminX)  # 坐标1
            x1 = int(self.PpointminX[0])
            y1 = int(self.PHg - self.PpointminY[0])
            # 坐标2
            x2 = int(self.PpointmaxX[0])
            y2 = int(self.PHg - self.PpointmaxY[0])
            # 计算宽，高
            w = x2 - x1
            h = y2 - y1
            print(w)
            print(h)
            img = img[y2:y1, x1:x2, :]
            print(img)
            cv2.imwrite(save_path + '/2.png', img)
            # 原始图片展示
            img = QPixmap(save_path + '/2.png')
            scarePixmap = img.scaled(471, 321, aspectRatioMode=Qt.KeepAspectRatio)
            self.dlg.showP.setPixmap(scarePixmap)

    #获取最小的x坐标 单位 像素
    def getPblocklX(self):
        return self.PblockminX
    # 获取最小的y坐标 单位 像素
    def getPblocklY(self):
        return self.PblockminY
    # 获取最大的x坐标 单位 像素
    def getPblockrX(self):
        return self.PblockmaxX
    #获取最大的y坐标 单位 像素
    def getPblockrY(self):
        return self.PblockmaxY













